// @version=6
// SwingTrendPositional_EntryExit.pine
// Multi-mode long-only TradingView indicator to suggest precise entries and exits
// Uses price-action (market structure), time-action (higher timeframe trend), and volume profile
// Designed for non-intraday traders (swing / trend / positional)

indicator("Swing/Trend/Positional Entry & Exit (Long Only)", overlay=true, max_lines_count=200, max_labels_count=200)

// ======== USER INPUTS ========
mode = input.string(defval = "Swing", title = "Mode", options = ["Swing", "Trend", "Positional"], tooltip = "Choose trading style: Swing (shorter), Trend (medium), Positional (longer)")
htf = input.timeframe(defval = "D", title = "Higher Timeframe for Trend & VP", tooltip = "Higher timeframe to measure the primary trend and volume profile (daily or weekly recommended)")
vp_lookback = input.int(defval = 200, minval = 20, title = "Volume Profile Lookback (bars on HTF)")
vp_bins = input.int(defval = 24, minval = 8, maxval = 200, title = "VP Bins")
vp_use = input.bool(true, "Use Volume Profile in signals")
ma_len = input.int(200, "HTF Trend MA length", minval=10)
atr_len = input.int(21, "ATR length")
atr_mult = input.float(1.5, "ATF stop-loss multiplier")
vol_spike_mult = input.float(1.75, "Volume spike multiplier (for confirmation)")
min_breakout_percent = input.float(0.25, "Breakout % above swing high (0-5)")
show_sl_tp = input.bool(true, "Show SL/TP lines")
label_size = input.string(defval = "normal", title="Label size", options=["small","normal","large"]) 

// Mode-specific defaults (internal)
swing_lookback = mode == "Swing" ? 20 : mode == "Trend" ? 50 : 200
swing_confirmation_bars = mode == "Swing" ? 2 : mode == "Trend" ? 3 : 5

// ======== UTILITIES ========
atr = ta.atr(atr_len)

// Fetch HTF series
htf_close = request.security(syminfo.tickerid, htf, close)
htf_high = request.security(syminfo.tickerid, htf, high)
htf_low = request.security(syminfo.tickerid, htf, low)
htf_vol = request.security(syminfo.tickerid, htf, volume)
htf_time = request.security(syminfo.tickerid, htf, time)

// HTF moving average for trend bias
htf_ma = request.security(syminfo.tickerid, htf, ta.sma(close, ma_len))
htf_ma_color = htf_close >= htf_ma ? color.green : color.red
plot(request.security(syminfo.tickerid, htf, ta.sma(close, ma_len)), title = "HTF MA", color = htf_ma_color, linewidth=2)

// Volume averages (calculated globally for consistency)
vol_avg = ta.sma(volume, 50)
vol_avg_20 = ta.sma(volume, 20)

// ======== MARKET STRUCTURE (Swing highs/lows) ========
pivot_left = swing_lookback
pivot_right = swing_lookback
ph = ta.pivothigh(high, pivot_left, pivot_right)
pl = ta.pivotlow(low, pivot_left, pivot_right)

// Calculate pivot highs series for resistance detection (global for consistency)
pivot_highs_series = ta.pivothigh(high, pivot_left, pivot_right)

var float lastSwingHigh = na
var int lastSwingHighBar = na
var float lastSwingLow = na
var int lastSwingLowBar = na
if not na(ph)
    lastSwingHigh := ph
    lastSwingHighBar := bar_index - pivot_right
if not na(pl)
    lastSwingLow := pl
    lastSwingLowBar := bar_index - pivot_right

plotshape(not na(ph) ? ph : na, style=shape.triangledown, location=location.absolute, color=color.orange, size=size.tiny, title="Pivot High")
plotshape(not na(pl) ? pl : na, style=shape.triangleup, location=location.absolute, color=color.lime, size=size.tiny, title="Pivot Low")

confirmed_swh = na(lastSwingHighBar) ? false : (bar_index - lastSwingHighBar >= swing_confirmation_bars)
swing_high_level = confirmed_swh and not na(lastSwingHigh) ? lastSwingHigh : na

breakout_px = swing_high_level * (1 + min_breakout_percent/100.0)

// ======== VOLUME PROFILE APPROXIMATION (on HTF)
// Simplified volume profile using HTF series data
var float[] vp_bins_arr = array.new<float>()
var float vp_low = na
var float vp_high = na
var float vp_poc = na

if vp_use
    // Use HTF series directly for volume profile calculation
    htf_range_high = ta.highest(htf_high, vp_lookback)
    htf_range_low = ta.lowest(htf_low, vp_lookback)
    
    if not na(htf_range_high) and not na(htf_range_low) and htf_range_high > htf_range_low
        vp_high := htf_range_high
        vp_low := htf_range_low
        
        // Simplified POC calculation - use current HTF close as approximation
        // In a real implementation, you'd accumulate volume at price levels
        price_range = vp_high - vp_low
        current_price_rel = (htf_close - vp_low) / price_range
        
        // Approximate POC as weighted average of recent price action
        vp_poc := vp_low + (price_range * 0.5) // Simple midpoint as POC approximation

f_get_poc(_bins_arr, _low, _high) =>
    if na(_low) or na(_high)
        [na, na]
    else
        // Simplified POC calculation
        poc_price = _low + (_high - _low) * 0.5
        [poc_price, 1.0]

// Draw VP visuals at global scope
var line vp_line = na
if vp_use and not na(vp_poc)
    if na(vp_line)
        vp_line := line.new(bar_index - 5, vp_poc, bar_index + 1, vp_poc, xloc = xloc.bar_index, extend = extend.right, color=color.new(color.blue, 40), width=2)
    else
        line.set_xy1(vp_line, bar_index - 5, vp_poc)
        line.set_xy2(vp_line, bar_index + 1, vp_poc)

// ======== ENTRY / EXIT RULES ========
htf_bull = htf_close > htf_ma
price_above_htf_ma = close > htf_ma
vol_spike = volume > vol_avg * vol_spike_mult
price_breakout = false

if not na(swing_high_level) and not na(breakout_px)
    price_breakout := close > breakout_px and bar_index > lastSwingHighBar

// HTF breakout logic
htf_last_ph = request.security(syminfo.tickerid, htf, ta.pivothigh(high, swing_lookback, swing_lookback))
htf_price_breakout = false
if not na(htf_last_ph)
    htf_current_close = request.security(syminfo.tickerid, htf, close)
    htf_price_breakout := htf_current_close > htf_last_ph

vp_confirm = true
if vp_use and not na(vp_poc) and not na(vp_high) and not na(vp_low)
    vp_confirm := close >= vp_poc or math.abs(close - vp_poc) <= (vp_high - vp_low) * 0.10

// Entry conditions based on mode
enter = false
if mode == "Swing"
    enter := price_breakout and htf_bull and vol_spike and vp_confirm
else if mode == "Trend"
    enter := price_breakout and htf_bull and (volume > vol_avg_20) and vp_confirm
else // Positional
    enter := htf_price_breakout and price_above_htf_ma and vp_confirm

// Fixed variable declarations with proper typing
var float stop_loss = na
var float take_profit = na

if enter
    // Calculate stop loss
    base_stop = not na(lastSwingLow) ? lastSwingLow - atr * 0.5 : close - atr * atr_mult
    stop_loss := base_stop
    
    // Calculate take profit
    tp_multiplier = mode == "Swing" ? 2.5 : mode == "Trend" ? 4.0 : 8.0
    tp_by_atr = close + atr * tp_multiplier
    
    // Look for next resistance level using pre-calculated series
    var float next_res = na
    for i = 1 to 50
        if bar_index - i >= 0
            phv = pivot_highs_series[i]
            if not na(phv)
                next_res := phv
                break
    
    take_profit := not na(next_res) ? next_res : tp_by_atr

// Exit signal logic
ema_short = ta.ema(close, 8)
exit_signal = false
if not na(lastSwingLow)
    exit_signal := close < lastSwingLow or (volume < vol_avg_20 and close < ema_short)

// Labels and visualization
var label[] entries = array.new<label>()
var label[] exits = array.new<label>()

if enter
    label_style = label_size == "small" ? size.small : label_size == "large" ? size.large : size.normal
    entry_label = label.new(bar_index, low, text = "LONG", style=label.style_label_up, color=color.new(color.green,0), textcolor=color.white, size = label_style)
    array.push(entries, entry_label)
    
    // Draw SL/TP lines
    if show_sl_tp and not na(stop_loss) and not na(take_profit)
        line.new(bar_index, stop_loss, bar_index + 20, stop_loss, xloc=xloc.bar_index, extend=extend.right, color=color.red, width=2, style=line.style_dashed)
        line.new(bar_index, take_profit, bar_index + 20, take_profit, xloc=xloc.bar_index, extend=extend.right, color=color.green, width=2, style=line.style_dashed)

if exit_signal
    label_style = label_size == "small" ? size.small : label_size == "large" ? size.large : size.normal
    exit_label = label.new(bar_index, high, text = "EXIT", style=label.style_label_down, color=color.new(color.orange,0), textcolor=color.black, size = label_style)
    array.push(exits, exit_label)

// Plot VP POC (moved to global scope)
vp_poc_plot = vp_use and not na(vp_poc) ? vp_poc : na
plot(vp_poc_plot, title = "VP POC", style=plot.style_linebr, linewidth=1, color=color.new(color.blue, 0))

// Alert conditions
alertcondition(enter, title = "Long Entry Signal", message = "SwingTrendPositional: LONG entry signaled on {{ticker}} at price {{close}}")
alertcondition(exit_signal, title = "Exit Signal", message = "SwingTrendPositional: EXIT signaled on {{ticker}} at price {{close}}")

// Draw swing levels
if not na(lastSwingHigh) and not na(lastSwingHighBar)
    line.new(lastSwingHighBar, lastSwingHigh, bar_index + 1, lastSwingHigh, xloc = xloc.bar_index, extend = extend.right, color=color.orange, width=1)
if not na(lastSwingLow) and not na(lastSwingLowBar)
    line.new(lastSwingLowBar, lastSwingLow, bar_index + 1, lastSwingLow, xloc = xloc.bar_index, extend = extend.right, color=color.lime, width=1)

// Summary label
var label summary_label = na
if barstate.islast
    if not na(summary_label)
        label.delete(summary_label)
    htf_trend_text = htf_bull ? "Bull" : "Bear"
    vp_poc_text = not na(vp_poc) ? str.tostring(vp_poc, format.mintick) : "n/a"
    summary_text = 'Mode: ' + mode + '\nHTF: ' + htf + '\nHTF Trend: ' + htf_trend_text + '\nVP POC: ' + vp_poc_text
    summary_label := label.new(bar_index, high, summary_text, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=color.new(color.gray,85), textcolor=color.white)

// End of indicator
